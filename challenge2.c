#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define FULL_SPEED 60
#define SLOW_SPEED 40
#define SLOWER_SPEED 30
#define BACK_SPEED -30

// number of cycles through the motor controller loop
// since the robot changed direction last
// used to make wander smoother and less wiggly
int cyclesSinceLastDirectionChange; //set to zero on black line or sensor detects object

// control flag for whether the program is running or not
// unused in this program, as no action should make the program exit
bool running;


void wander();

task main()
{
	running = true;
	while(running) {
		//do stuff
	}
}

/*
Causes the robot to move in a biased random walk, choosing to either continue straight, turn left, or turn
right in a random pattern with a bias towards moving in one direction.
*/
void wander() {
	if (cyclesSinceLastDirectionChange++ >= 20) {
		setLEDColor(ledOff);
		switch (random(10)){
			case 0: //continue straight
				motor[leftMotor] = FULL_SPEED;
				motor[rightMotor] = FULL_SPEED;
				cyclesSinceLastDirectionChange = 0;
				//setLEDColor(ledOrange);
				break;
			case 1: //turn right
				motor[rightMotor] = SLOW_SPEED;
				motor[leftMotor] = FULL_SPEED;
				cyclesSinceLastDirectionChange = 0;
				setLEDColor(ledRed);
				break;
			case 2: //turn left
				motor[leftMotor] = SLOW_SPEED;
				motor[rightMotor] = FULL_SPEED;
				cyclesSinceLastDirectionChange = 0;
				//setLEDColor(ledGreen);
				break;
			default: //Continue either turning or going straight.
				//Check if the robot is stopped as the result of a collision, if so continue straight
				if (!(motor[leftMotor] || motor[rightMotor])) {
					motor[leftMotor] = FULL_SPEED;
					motor[rightMotor] = FULL_SPEED;
					cyclesSinceLastDirectionChange = 0;
					//setLEDColor(ledOrange);
				}
				break;
		}
	}
}
